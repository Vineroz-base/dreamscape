<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Dreamscape Roguelite</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #0a0a0a;
      color: #e6e6e6;
      font-family: sans-serif;
      overflow: hidden;
      height: 100%;
      width: 100%;
    }
    #gameCanvas {
      display: block;
      margin: auto;
      background: #000;
      width: 100vw;
      height: 100vh;
      touch-action: none;
    }
    #hud {
      position: absolute;
      top: 10px;
      left: 0;
      right: 0;
      text-align: center;
      font-size: 18px;
      pointer-events: none;
      z-index: 2;
    }
    #buttons {
      position: absolute;
      bottom: 10px;
      left: 0;
      right: 0;
      text-align: center;
      z-index: 2;
    }
    button {
      font-size: 16px;
      margin: 0 10px;
      padding: 8px 16px;
    }
    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      font-weight: bold;
      z-index: 3;
      display: none;
      flex-direction: column;
    }
    #message {
      position: absolute;
      bottom: 60px;
      left: 0;
      right: 0;
      text-align: center;
      font-size: 14px;
      color: #0ff;
      opacity: 0;
      transition: opacity 0.5s;
      z-index: 2;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="360" height="640"></canvas>
  <div id="hud">HP: <span id="hp">100</span> | Shards: <span id="shards">0</span></div>
  <div id="buttons">
    <button onclick="startRun()">Start Run</button>
    <button onclick="resetProgress()">Reset</button>
  </div>
  <div id="overlay">Game Over<br><small>Tap 'Start Run' to try again</small></div>
  <div id="message">Progress Reset</div>
  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const width = 360, height = 640;
    canvas.width = width;
    canvas.height = height;

    let player = { x: 180, y: 320, size: 10, hp: 100, lastHit: 0, flash: 0 };
    let shards = [];
    let obstacles = [];
    let totalShards = 0;
    let runActive = false;
    let lastTime = 0;

    const hpEl = document.getElementById("hp");
    const shardsEl = document.getElementById("shards");
    const overlay = document.getElementById("overlay");
    const message = document.getElementById("message");

    function loadShards() {
      try {
        totalShards = parseInt(localStorage.getItem("shards")) || 0;
      } catch (e) {
        totalShards = 0;
      }
      shardsEl.textContent = totalShards;
    }

    function saveShards() {
      try {
        localStorage.setItem("shards", totalShards);
      } catch (e) {}
    }

    function resetProgress() {
      try {
        localStorage.removeItem("shards");
      } catch (e) {}
      totalShards = 0;
      shardsEl.textContent = totalShards;
      message.style.opacity = 1;
      setTimeout(() => { message.style.opacity = 0; }, 2000);
    }

    function startRun() {
      player.x = 180;
      player.y = 320;
      player.hp = 100;
      player.lastHit = 0;
      player.flash = 0;
      shards = [];
      obstacles = [];
      for (let i = 0; i < 15; i++) {
        shards.push({ x: Math.random() * width, y: Math.random() * height, pulse: Math.random() * Math.PI * 2 });
      }
      for (let i = 0; i < 7; i++) {
        obstacles.push({ 
          x: Math.random() * width, 
          y: Math.random() * height, 
          vx: (Math.random() - 0.5) * 100, 
          vy: (Math.random() - 0.5) * 100 
        });
      }
      runActive = true;
      overlay.style.display = "none";
      lastTime = performance.now();
      requestAnimationFrame(gameLoop);
    }

    function gameLoop(timestamp) {
      if (!runActive) return;
      let dt = (timestamp - lastTime) / 1000;
      lastTime = timestamp;
      dt = Math.min(dt, 0.1);

      update(dt, timestamp);
      draw(timestamp);

      if (player.hp > 0) {
        requestAnimationFrame(gameLoop);
      } else {
        runActive = false;
        overlay.style.display = "flex";
      }
    }

    function update(dt, now) {
      for (let o of obstacles) {
        o.x += o.vx * dt;
        o.y += o.vy * dt;
        if (o.x < 0 || o.x > width) o.vx *= -1;
        if (o.y < 0 || o.y > height) o.vy *= -1;
        if (Math.abs(o.x - player.x) < 15 && Math.abs(o.y - player.y) < 15) {
          if (now - player.lastHit > 600) {
            player.hp = Math.max(0, player.hp - 10);
            player.lastHit = now;
            player.flash = 0.3;
          }
        }
      }

      for (let i = shards.length - 1; i >= 0; i--) {
        let s = shards[i];
        if (Math.abs(s.x - player.x) < 10 && Math.abs(s.y - player.y) < 10) {
          shards.splice(i, 1);
          totalShards++;
          shardsEl.textContent = totalShards;
          saveShards();
        }
      }

      if (player.flash > 0) {
        player.flash -= dt;
      }

      hpEl.textContent = player.hp;
    }

    function draw(time) {
      ctx.clearRect(0, 0, width, height);

      // Background starfield
      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, width, height);
      ctx.fillStyle = "#111";
      for (let i = 0; i < 50; i++) {
        let x = (i * 73 + time * 0.05) % width;
        let y = (i * 37 + time * 0.03) % height;
        ctx.fillRect(x, y, 2, 2);
      }

      // Shards
      for (let s of shards) {
        s.pulse += 0.1;
        let r = 5 + Math.sin(s.pulse) * 2;
        ctx.save();
        ctx.fillStyle = "#0ff";
        ctx.shadowColor = "#0ff";
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(s.x, s.y, r, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      // Obstacles
      ctx.fillStyle = "#f00";
      for (let o of obstacles) {
        ctx.beginPath();
        ctx.arc(o.x, o.y, 10, 0, Math.PI * 2);
        ctx.fill();
      }

      // Player
      ctx.fillStyle = player.flash > 0 ? "#f00" : "#0f0";
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);
      ctx.fill();
    }

    let inputStart = null;

    function handleInputEnd(x, y) {
      if (!inputStart) return;
      let dx = x - inputStart.x;
      let dy = y - inputStart.y;
      let dist = Math.hypot(dx, dy);
      if (dist < 10) return;
      let angle = Math.atan2(dy, dx);
      player.x += Math.cos(angle) * 30;
      player.y += Math.sin(angle) * 30;
      player.x = Math.max(0, Math.min(width, player.x));
      player.y = Math.max(0, Math.min(height, player.y));
      inputStart = null;
    }

    canvas.addEventListener("touchstart", e => {
      if (e.touches.length > 0) {
        const rect = canvas.getBoundingClientRect();
        inputStart = { 
          x: (e.touches[0].clientX - rect.left) * (width / rect.width), 
          y: (e.touches[0].clientY - rect.top) * (height / rect.height) 
        };
      }
    });

    canvas.addEventListener("touchend", e => {
      if (e.changedTouches.length > 0) {
        const rect = canvas.getBoundingClientRect();
        handleInputEnd(
          (e.changedTouches[0].clientX - rect.left) * (width / rect.width),
          (e.changedTouches[0].clientY - rect.top) * (height / rect.height)
        );
      }
    });

    canvas.addEventListener("mousedown", e => {
      const rect = canvas.getBoundingClientRect();
      inputStart = { 
        x: (e.clientX - rect.left) * (width / rect.width), 
        y: (e.clientY - rect.top) * (height / rect.height) 
      };
    });

    canvas.addEventListener("mouseup", e => {
      const rect = canvas.getBoundingClientRect();
      handleInputEnd(
        (e.clientX - rect.left) * (width / rect.width), 
        (e.clientY - rect.top) * (height / rect.height)
      );
    });

    loadShards();
  </script>
</body>
</html>
