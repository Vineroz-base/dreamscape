<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no" />
  <title>Dreamscape Roguelite</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #0a0a0a;
      color: #e6e6e6;
      font-family: sans-serif;
      overflow: hidden;
      height: 100%;
      width: 100%;
    }
    #gameCanvas {
      display: block;
      margin: auto;
      background: #000;
      width: 100vw;
      height: 100vh;
      touch-action: none;
    }
    #hud {
      position: absolute;
      top: 10px;
      left: 0;
      right: 0;
      text-align: center;
      font-size: 18px;
      pointer-events: none;
      z-index: 2;
    }
    #buttons {
      position: absolute;
      bottom: 10px;
      left: 0;
      right: 0;
      text-align: center;
      z-index: 2;
    }
    button {
      font-size: 16px;
      margin: 0 10px;
      padding: 8px 16px;
    }
    #overlay {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      font-weight: bold;
      z-index: 3;
      flex-direction: column;
    }
    #message {
      position: absolute;
      bottom: 60px;
      left: 0; right: 0;
      text-align: center;
      font-size: 14px;
      color: #0ff;
      opacity: 0;
      transition: opacity 0.5s;
      z-index: 2;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="360" height="640"></canvas>
  <div id="hud">HP: <span id="hp">100</span> | Shards: <span id="shards">0</span></div>
  <div id="buttons">
    <button onclick="startRun()">Start Run</button>
    <button onclick="resetProgress()">Reset</button>
  </div>
  <div id="overlay">Game Over<br><small>Tap 'Start Run' to try again</small></div>
  <div id="message">Progress Reset</div>
<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const width = 360, height = 640;
canvas.width = width; canvas.height = height;

let player = { x: 180, y: 320, size: 12, hp: 100, vx: 0, vy: 0 };
let shards = [], obstacles = [], stars = [];
let totalShards = 0;
let runActive = false;
let lastTime = 0;

const hpEl = document.getElementById("hp");
const shardsEl = document.getElementById("shards");
const overlay = document.getElementById("overlay");
const message = document.getElementById("message");

function loadShards() {
  try { totalShards = parseInt(localStorage.getItem("shards")) || 0; }
  catch(e){ totalShards = 0; }
  shardsEl.textContent = totalShards;
}
function saveShards() {
  try { localStorage.setItem("shards", totalShards); } catch(e){}
}
function resetProgress() {
  try { localStorage.removeItem("shards"); } catch(e){}
  totalShards = 0;
  shardsEl.textContent = totalShards;
  message.style.opacity = 1;
  setTimeout(()=>{ message.style.opacity = 0; },2000);
}

function startRun() {
  player.x=180; player.y=320; player.hp=100; player.vx=0; player.vy=0;
  shards=[]; obstacles=[]; stars=[];
  for(let i=0;i<15;i++){
    shards.push({x:Math.random()*width,y:Math.random()*height,pulse:Math.random()*Math.PI*2});
  }
  for(let i=0;i<7;i++){
    obstacles.push({x:Math.random()*width,y:Math.random()*height,vx:(Math.random()-0.5)*60,vy:(Math.random()-0.5)*60});
  }
  for(let i=0;i<50;i++){
    stars.push({x:Math.random()*width,y:Math.random()*height,speed:20+Math.random()*40});
  }
  runActive=true; overlay.style.display="none"; lastTime=performance.now();
  requestAnimationFrame(gameLoop);
}

function gameLoop(timestamp){
  if(!runActive) return;
  let dt=(timestamp-lastTime)/1000; lastTime=timestamp;
  dt=Math.min(dt,0.05);
  update(dt); draw();
  if(player.hp>0){ requestAnimationFrame(gameLoop); }
  else { runActive=false; overlay.style.display="flex"; }
}

function update(dt){
  // player movement
  player.x+=player.vx*dt; player.y+=player.vy*dt;
  player.vx*=0.92; player.vy*=0.92;
  player.x=Math.max(0,Math.min(width,player.x));
  player.y=Math.max(0,Math.min(height,player.y));

  // obstacles
  for(let o of obstacles){
    o.x+=o.vx*dt; o.y+=o.vy*dt;
    if(o.x<0||o.x>width) o.vx*=-1;
    if(o.y<0||o.y>height) o.vy*=-1;
    let dx=o.x-player.x, dy=o.y-player.y;
    if(Math.hypot(dx,dy)<20){
      player.hp=Math.max(0,player.hp-1); // continuous drain
    }
  }

  // shards
  for(let i=shards.length-1;i>=0;i--){
    let s=shards[i];
    if(Math.hypot(s.x-player.x,s.y-player.y)<15){
      shards.splice(i,1);
      totalShards++;
      shardsEl.textContent=totalShards;
      saveShards();
    }
  }

  // stars
  for(let st of stars){
    st.y+=st.speed*dt;
    if(st.y>height){ st.y=0; st.x=Math.random()*width; }
  }

  hpEl.textContent=player.hp;
}

function draw(){
  ctx.clearRect(0,0,width,height);
  // background stars
  ctx.fillStyle="#000"; ctx.fillRect(0,0,width,height);
  ctx.fillStyle="#111";
  for(let st of stars){ ctx.fillRect(st.x,st.y,2,2); }

  // shards
  for(let s of shards){
    s.pulse+=0.1; let r=5+Math.sin(s.pulse)*2;
    ctx.save();
    ctx.fillStyle="#0ff"; ctx.shadowColor="#0ff"; ctx.shadowBlur=10;
    ctx.beginPath(); ctx.arc(s.x,s.y,r,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }

  // obstacles
  ctx.fillStyle="#f00";
  for(let o of obstacles){
    ctx.beginPath(); ctx.rect(o.x-10,o.y-5,20,10); ctx.fill();
  }

  // player
  ctx.save();
  ctx.fillStyle="#0f0"; ctx.shadowColor="#0f0"; ctx.shadowBlur=15;
  ctx.beginPath(); ctx.arc(player.x,player.y,player.size,0,Math.PI*2); ctx.fill();
  ctx.restore();
}

// input
let inputStart=null;
function handleInputEnd(x,y){
  if(!inputStart) return;
  let dx=x-inputStart.x, dy=y-inputStart.y;
  let dist=Math.hypot(dx,dy);
  if(dist<10) return;
  let angle=Math.atan2(dy,dx);
  player.vx+=Math.cos(angle)*120;
  player.vy+=Math.sin(angle)*120;
  inputStart=null;
}
canvas.addEventListener("touchstart",e=>{
  if(e.touches.length>0){
    const rect=canvas.getBoundingClientRect();
    inputStart={x:(e.touches[0].clientX-rect.left)*(width/rect.width),
                y:(e.touches[0].clientY-rect.top)*(height/rect.height)};
  }
});
canvas.addEventListener("touchend",e=>{
  if(e.changedTouches.length>0){
    const rect=canvas.getBoundingClientRect();
    handleInputEnd((e.changedTouches[0].clientX-rect.left)*(width / rect.width),
          (e.changedTouches[0].clientY - rect.top) * (height / rect.height)
        );
      }
    });

    canvas.addEventListener("mousedown", e => {
      const rect = canvas.getBoundingClientRect();
      inputStart = {
        x: (e.clientX - rect.left) * (width / rect.width),
        y: (e.clientY - rect.top) * (height / rect.height)
      };
    });

    canvas.addEventListener("mouseup", e => {
      const rect = canvas.getBoundingClientRect();
      handleInputEnd(
        (e.clientX - rect.left) * (width / rect.width),
        (e.clientY - rect.top) * (height / rect.height)
      );
    });

    loadShards();
  </script>
</body>
</html>
