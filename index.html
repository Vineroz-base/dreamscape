<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Dreamscape Roguelite</title>
<style>
  :root {
    --bg: #0a0a0a;
    --fg: #e6e6e6;
    --accent: #47e9ff;
    --accent2: #a88cff;
    --danger: #ff4d6d;
    --glow: 0 0 12px rgba(71,233,255,0.6), 0 0 24px rgba(71,233,255,0.4);
    --glow2: 0 0 12px rgba(168,140,255,0.6), 0 0 24px rgba(168,140,255,0.4);
    --glowDanger: 0 0 12px rgba(255,77,109,0.6), 0 0 24px rgba(255,77,109,0.4);
  }
  html, body {
    height: 100%;
    background: var(--bg);
    color: var(--fg);
  }
  body {
    margin: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
  }
  #wrap {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
    width: 100%;
    max-width: 420px;
    padding: 12px;
  }
  #title {
    font-weight: 600;
    letter-spacing: 0.5px;
    color: var(--fg);
    text-align: center;
    text-shadow: var(--glow2);
  }
  #game {
    width: 100%;
    aspect-ratio: 360 / 640;
    background: #000;
    border-radius: 14px;
    box-shadow: 0 0 0 2px #232323, 0 6px 24px rgba(0,0,0,0.6), var(--glow);
    touch-action: none;
  }
  #hud {
    width: 100%;
    display: grid;
    grid-template-columns: 1fr auto 1fr;
    align-items: center;
    gap: 10px;
  }
  .pill {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 10px 14px;
    border-radius: 999px;
    background: #111;
    box-shadow: 0 0 0 1px #222, 0 6px 18px rgba(0,0,0,0.5);
    min-width: 120px;
  }
  .stat {
    font-weight: 600;
    letter-spacing: 0.3px;
  }
  .accent { color: var(--accent) }
  .accent2 { color: var(--accent2) }
  .danger { color: var(--danger) }
  button {
    appearance: none;
    border: none;
    border-radius: 999px;
    padding: 10px 16px;
    background: linear-gradient(180deg, #151515, #0e0e0e);
    color: var(--fg);
    font-weight: 600;
    letter-spacing: 0.3px;
    box-shadow: 0 0 0 1px #222, var(--glow2);
    transition: transform 120ms ease, box-shadow 120ms ease, background 120ms ease;
  }
  button:active { transform: scale(0.98) }
  #hint {
    font-size: 12px;
    opacity: 0.8;
    text-align: center;
  }
</style>
</head>
<body>
  <div id="wrap">
    <div id="title">Dreamscape Roguelite</div>
    <canvas id="game" width="360" height="640"></canvas>
    <div id="hud">
      <div class="pill"><span class="stat danger">❤ <span id="hp">100</span></span></div>
      <button id="reset">Reset</button>
      <div class="pill"><span class="stat accent2">✦ <span id="totalShards">0</span></span></div>
    </div>
    <div id="hint">Swipe to move. Tap to dash. Collect glowing shards.</div>
  </div>

<script>
  const W = 360, H = 640
  const canvas = document.getElementById('game')
  const ctx = canvas.getContext('2d', { alpha: false })
  let scaleX = 1, scaleY = 1
  function resize() {
    const rect = canvas.getBoundingClientRect()
    scaleX = canvas.width / rect.width
    scaleY = canvas.height / rect.height
  }
  new ResizeObserver(resize).observe(canvas)

  const storageKey = 'dreamscape_total_shards'
  let totalShards = parseInt(localStorage.getItem(storageKey) || '0', 10)
  const totalShardsEl = document.getElementById('totalShards')
  totalShardsEl.textContent = totalShards

  const hpEl = document.getElementById('hp')
  document.getElementById('reset').addEventListener('click', () => {
    totalShards = 0
    localStorage.setItem(storageKey, '0')
    totalShardsEl.textContent = totalShards
  })

  const player = {
    x: W/2, y: H*0.7, w: 18, h: 18,
    vx: 0, vy: 0, speed: 2.2, dash: 5.0, hp: 100
  }

  let shards = []
  let particles = []
  let obstacles = []
  let lastTime = performance.now()
  let touchStart = null
  let dashTarget = null

  function rand(a,b){ return Math.random()*(b-a)+a }
  function irand(a,b){ return Math.floor(rand(a,b)) }
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)) }

  function spawnShards(n=16) {
    shards = []
    for (let i=0; i<n; i++) {
      const r = rand(6, 9)
      const x = rand(r+10, W - r - 10)
      const y = rand(r+10, H - r - 80)
      shards.push({
        x, y, r,
        hue: irand(180, 260),
        pulse: rand(0, Math.PI*2)
      })
    }
  }

  function spawnObstacles(n=6) {
    obstacles = []
    for (let i=0;i<n;i++){
      const w = rand(18, 40), h = rand(8, 14)
      const x = rand(10, W-10-w)
      const y = rand(60, H-160)
      const vx = rand(-0.6, 0.6)
      obstacles.push({x,y,w,h,vx})
    }
  }

  function aabb(ax,ay,aw,ah,bx,by,bw,bh){
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by
  }
  function circleRect(cx,cy,cr,rx,ry,rw,rh){
    const nx = clamp(cx, rx, rx+rw)
    const ny = clamp(cy, ry, ry+rh)
    const dx = cx - nx, dy = cy - ny
    return dx*dx + dy*dy <= cr*cr
  }

  function addParticle(x,y,color){
    particles.push({x,y,life: 1, color})
  }
  function updateParticles(dt){
    for (let p of particles) p.life -= dt*1.8
    particles = particles.filter(p=>p.life>0)
  }
  function drawParticles(){
    for (let p of particles){
      const a = Math.max(0, Math.min(1, p.life))
      ctx.fillStyle = `rgba(${p.color[0]},${p.color[1]},${p.color[2]},${a})`
      ctx.fillRect(p.x-1, p.y-1, 2, 2)
    }
  }

  function drawBackground(t){
    ctx.fillStyle = '#000'
    ctx.fillRect(0,0,W,H)
    const g = ctx.createLinearGradient(0,0,0,H)
    g.addColorStop(0, 'rgba(15,15,25,0.4)')
    g.addColorStop(1, 'rgba(0,0,0,0.2)')
    ctx.fillStyle = g
    ctx.fillRect(0,0,W,H)
    ctx.globalCompositeOperation = 'lighter'
    ctx.fillStyle = 'rgba(20,40,60,0.08)'
    for (let i=0;i<40;i++){
      const px = (i*97 + t*0.03)%W
      const py = (i*59 + t*0.05)%H
      ctx.fillRect(px, py, 2, 2)
    }
    ctx.globalCompositeOperation = 'source-over'
  }

  function drawShards(t){
    for (let s of shards){
      s.pulse += 0.03
      const k = 0.5 + Math.sin(s.pulse)*0.25
      ctx.beginPath()
      ctx.arc(s.x, s.y, s.r*(0.9+k*0.2), 0, Math.PI*2)
      ctx.closePath()
      ctx.fillStyle = `hsl(${s.hue} 80% 60% / 0.10)`
      ctx.fill()
      ctx.beginPath()
      ctx.arc(s.x, s.y, s.r, 0, Math.PI*2)
      ctx.closePath()
      ctx.fillStyle = `hsl(${s.hue} 80% 60% / 0.85)`
      ctx.shadowColor = `hsl(${s.hue} 90% 65%)`
      ctx.shadowBlur = 12
      ctx.fill()
      ctx.shadowBlur = 0
    }
  }

  function drawObstacles(){
    for (let o of obstacles){
      ctx.fillStyle = 'rgba(255,77,109,0.10)'
      ctx.fillRect(o.x-2, o.y-2, o.w+4, o.h+4)
      ctx.fillStyle = 'rgba(255,77,109,0.85)'
      ctx.fillRect(o.x, o.y, o.w, o.h)
    }
  }

  function drawPlayer(){
    ctx.fillStyle = 'rgba(71,233,255,0.15)'
    ctx.fillRect(player.x-4, player.y-4, player.w+8, player.h+8)
    ctx.fillStyle = 'rgba(71,233,255,0.95)'
    ctx.fillRect(player.x, player.y, player.w, player.h)
  }

  function collectShard(i){
    const s = shards[i]
    addParticle(s.x, s.y, [120,220,255])
    shards.splice(i,1)
    totalShards++
    localStorage.setItem(storageKey, String(totalShards))
    totalShardsEl.textContent = totalShards
  }

  function updateObstacles(dt){
    for (let o of obstacles){
      o.x += o.vx
      if (o.x < 10 || o.x+o.w > W-10) o.vx *= -1
      if (aabb(player.x,player.y,player.w,player.h,o.x,o.y,o.w,o.h)){
        player.hp = Math.max(0, player.hp - 10*dt)
        hpEl.textContent = Math.round(player.hp)
        addParticle(player.x+player.w/2, player.y+player.h/2, [255,64,96])
      }
    }
  }

  function updatePlayer(dt){
    if (dashTarget){
      const dx = dashTarget.x - (player.x + player.w/2)
      const dy = dashTarget.y - (player.y + player.h/2)
      const d = Math.hypot(dx,dy)
      if (d > 2){
        player.vx = (dx/d) * player.dash
        player.vy = (dy/d) * player.dash
      } else {
        dashTarget = null
        player.vx = 0
        player.vy = 0
      }
    }
    player.x += player.vx
    player.y += player.vy
    player.x = clamp(player.x, 6, W - player.w - 6)
    player.y = clamp(player.y, 50, H - player.h - 80)
    player.vx *= 0.92
    player.vy *= 0.92
  }

  function updateShards(){
    for (let i=shards.length-1;i>=0;i--){
      if (circleRect(shards[i].x, shards[i].y, shards[i].r, player.x, player.y, player.w, player.h)){
        collectShard(i)
      }
    }
  }

  function step(t){
    const now = performance.now()
    const dt = Math.min(0.033, (now - lastTime)/1000)
    lastTime = now
    updateParticles(dt)
    updateObstacles(dt)
    updatePlayer(dt)
    updateShards()
    drawBackground(t)
    drawObstacles()
    drawShards(t)
    drawPlayer()
    requestAnimationFrame(step)
  }

  function startRun(){
    player.x = W/2 - player.w/2
    player.y = H*0.7 - player.h/2
    player.vx = 0
    player.vy = 0
    player.hp = 100
    hpEl.textContent = 100
    spawnShards(18)
    spawnObstacles(7)
    lastTime = performance.now()
  }

  function canvasPointFromEvent(e){
    const rect = canvas.getBoundingClientRect()
    let clientX, clientY
    if (e.touches && e.touches[0]){
      clientX = e.touches[0].clientX
      clientY = e.touches[0].clientY
    } else {
      clientX = e.clientX
      clientY = e.clientY
    }
    const x = (clientX - rect.left) * scaleX
    const y = (clientY - rect.top) * scaleY
    return { x, y }
  }

  canvas.addEventListener('touchstart', e=>{
    e.preventDefault()
    touchStart = { point: canvasPointFromEvent(e), time: performance.now() }
  }, { passive: false })

  canvas.addEventListener('touchend', e=>{
    e.preventDefault()
    const endPoint = touchStart ? touchStart.point : null
    const now = performance.now()
    if (!endPoint) return
    const dt = now - touchStart.time
    const startP = endPoint
    const endP = canvasPointFromEvent(e.changedTouches[0] || e)
    const dx = endP.x - startP.x
    const dy = endP.y - startP.y
    const dist = Math.hypot(dx,dy)
    if (dist < 12 || dt < 180){
      dashTarget = { x: endP.x, y: endP.y }
    } else {
      const d = Math.max(1, dist)
      player.vx = (dx/d) * player.speed * 12/16
      player.vy = (dy/d) * player.speed * 12/16
      dashTarget = null
    }
    touchStart = null
  }, { passive: false })

  canvas.addEventListener('mousedown', e=>{
    const p = canvasPointFromEvent(e)
    touchStart = { point: p, time: performance.now() }
  })
  canvas.addEventListener('mouseup', e=>{
    const p = canvasPointFromEvent(e)
    const dt = performance.now() - touchStart.time
    const dx = p.x - touchStart.point.x
    const dy = p.y - touchStart.point.y
    const dist = Math.hypot(dx,dy)
    if (dist < 10 || dt < 160){
      dashTarget = { x: p.x, y: p.y }
    } else {
      const d = Math.max(1, dist)
      player.vx = (dx/d) * player.speed * 12/16
      player.vy = (dy/d) * player.speed * 12/16
      dashTarget = null
    }
    touchStart = null
  })

  startRun()
  requestAnimationFrame(step)
</script>
</body>
</html>